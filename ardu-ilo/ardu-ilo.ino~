bool abacaxi = 0;

const int led = 12;
const int botao = 13;

const int ultraL_trigger = A0;
const int ultraL_echo = 11;

const int ultraR_trigger = A1;
const int ultraR_echo = 3;

struct DCMotor {

	int speed = 255;
	int pin1;
	int pin2;
	bool invert = false;

	DCMotor() {}

	DCMotor(bool invert) {
		this->invert = invert;
	}

	~DCMotor() = default;

	void setPin(int in1, int in2) { 
		pin1 = in1;
		pin2 = in2;

		pinMode(pin1, OUTPUT);
		pinMode(pin2, OUTPUT);
	}

	void setSpeed(int in1) {
		speed = in1;
	}

	void fw() {
		analogWrite(pin1, speed);
		digitalWrite(pin2, LOW);
	}

	void bw() {
		digitalWrite(pin1, LOW);
		analogWrite(pin2, speed);
	}

	void forward() {
		if (!invert) {
			fw();
		} else {
			bw();
		}
	}

	void backward() {
		if (!invert) {
			bw();
		} else {
			fw();
		}
	}

	void stop() {
		digitalWrite(pin1, LOW);
		digitalWrite(pin2, LOW);
	}
};

DCMotor Motor1, Motor2(true); // Invert second motor control since it's wires are inverted

double ultraLeft(void) {

	digitalWrite(ultraL_trigger, HIGH);
	delayMicroseconds(10);
	digitalWrite(ultraL_trigger, LOW);

	double duration = pulseIn(ultraL_echo, HIGH);

	return (0.017f * duration);
}

void abort (void) {

	Motor1.stop();
	Motor2.stop();

	abacaxi = 0;

	digitalWrite(ultraR_trigger, LOW);
	digitalWrite(ultraL_trigger, LOW);
}

double ultraRight(void) {

	digitalWrite(ultraR_trigger, HIGH);
	delayMicroseconds(10);
	digitalWrite(ultraR_trigger, LOW);

	double duration = pulseIn(ultraR_echo, HIGH);

	return (0.017f * duration);
}

void turnRight(double time=500) {

	Motor1.forward();
	Motor2.backward();

	delay(time);

	Motor1.stop();
	Motor2.stop();
}

void turnLeft(double time=500) {

	Motor1.backward();
	Motor2.forward();

	delay(time);

	Motor1.stop();
	Motor2.stop();
}

void move(void) {

	byte turnedLeft = 0;
	byte turnedRight = 0;

	unsigned long start = millis();
	while ( (millis() - start) < 1500) {	// 1.5 s

		Motor1.forward(); 
		Motor2.forward();  

		double dL = ultraLeft();
		double dR = ultraRight();

		Serial.print(dL);
		Serial.print(", ");
		Serial.print(dR);
		Serial.println();

		if (dL < 20.0) {
			if (dL < 4.0) {
				abort();
				break;
			} else if (dL < 12.0) {
				turnRight(0.0);
				turnedRight++;
			} else if (dL > 16.0) {
				turnLeft(0.0);
				turnedLeft++;
			}
		}

		if (dR < 20.0) {
			if (dR < 4.0) {
				abort();
				break;
			} else if (dR < 12.0) {
				turnLeft(0.0);
				turnedLeft++;
			} else if (dR > 16.0) {
				turnRight(0.0);
				turnedRight++;
			}
		}

		if (turnedLeft > 50) {
			Motor1.backward();
			Motor2.backward();
			turnRight(10.0);
			turnedLeft = 0;
		}
		if (turnedRight > 50) {
			Motor1.backward();
			Motor2.backward();
			turnLeft(10.0);
			turnedRight = 0;
		}
	}
	Motor1.stop();
	Motor2.stop();
	Serial.println("frente!");
}

// estão prontos para receber os comandos já configurados acima.
void setup() {

	Serial.begin(9600);

	Motor1.setPin(5, 6); // Seleção dos pinos que cada motor usará, como descrito na classe.
	Motor2.setPin(9, 10);

	pinMode(led, OUTPUT);
	pinMode(botao, INPUT);

	pinMode(ultraL_trigger, OUTPUT);
	pinMode(ultraL_echo, INPUT);

	pinMode(ultraR_trigger, OUTPUT);
	pinMode(ultraR_echo, INPUT);
}

unsigned long start_loop = 0;

void loop() {

	if (abacaxi == 1) {

		if (digitalRead(botao) == LOW) {
			abacaxi = 0;
			digitalWrite(led, LOW);
			delay(500);

		} else if ( (millis() - start_loop) >= 3000) {

			delay(3000);

			move();
			start_loop = millis();
		}

	} else {

		if (digitalRead(botao) == LOW){
			abacaxi = 1;
			start_loop = millis();
			digitalWrite(led, HIGH);
			delay(500);
		}
	}
	delay(50);
}
